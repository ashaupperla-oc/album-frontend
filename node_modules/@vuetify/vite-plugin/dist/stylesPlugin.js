"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stylesPlugin = void 0;
const promises_1 = require("fs/promises");
const path = require("upath");
const debug_1 = require("debug");
const loader_shared_1 = require("@vuetify/loader-shared");
const debug = (0, debug_1.default)('vuetify:styles');
function isSubdir(root, test) {
    const relative = path.relative(root, test);
    return relative && !relative.startsWith('..') && !path.isAbsolute(relative);
}
const styleImportRegexp = /@use ['"]vuetify(\/lib)?\/styles(\/main(\.sass)?)?['"]/;
function stylesPlugin(options) {
    const vuetifyBase = path.dirname(require.resolve('vuetify/package.json'));
    const files = new Set();
    let server;
    let context;
    let resolve;
    let promise;
    let needsTouch = false;
    const blockingModules = new Set();
    let pendingModules;
    async function getPendingModules() {
        if (!server) {
            await new Promise(resolve => setTimeout(resolve, 0));
            const modules = Array.from(context.getModuleIds())
                .filter(id => !blockingModules.has(id)) // Ignore the current file
                .map(id => context.getModuleInfo(id))
                .filter(module => module.code == null); // Ignore already loaded modules
            pendingModules = modules.map(module => module.id);
            return (await Promise.all(modules.map(module => context.load(module)))).map(module => module.id);
        }
        else {
            const modules = Array.from(server.moduleGraph.urlToModuleMap.entries())
                .filter(([k, v]) => (v.transformResult == null &&
                !k.startsWith('/@id/') &&
                !blockingModules.has(v.id)));
            pendingModules = modules.map(([k, v]) => v.id);
            return (await Promise.all(modules.map(([k, v]) => server.transformRequest(k).then(() => v)))).map(module => module.id);
        }
    }
    let timeout;
    async function awaitBlocking() {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
            console.error('vuetify:styles fallback timeout hit', {
                blockingModules: Array.from(blockingModules.values()),
                pendingModules,
            });
            resolve(false);
        }, options.stylesTimeout);
        let pending;
        do {
            pending = await Promise.any([
                promise,
                getPendingModules().then(v => v.length)
            ]);
            debug(pending, 'pending modules', pendingModules);
        } while (pending);
        resolve(false);
    }
    async function awaitResolve(id) {
        var _a;
        if (id) {
            blockingModules.add(id);
        }
        if (!promise) {
            promise = new Promise((_resolve) => resolve = _resolve);
            awaitBlocking();
            await promise;
            clearTimeout(timeout);
            blockingModules.clear();
            debug('writing styles');
            await (0, loader_shared_1.writeStyles)(files);
            if (server && needsTouch) {
                (_a = server.moduleGraph.getModulesByFile((0, loader_shared_1.cacheDir)('styles.scss'))) === null || _a === void 0 ? void 0 : _a.forEach(module => {
                    module.importers.forEach(module => {
                        if (module.file) {
                            debug(`touching ${module.file}`);
                            (0, promises_1.utimes)(module.file, Date.now(), Date.now());
                        }
                    });
                });
                needsTouch = false;
            }
            promise = null;
        }
        return promise;
    }
    return {
        name: 'vuetify:styles',
        enforce: 'pre',
        configureServer(_server) {
            server = _server;
        },
        buildStart() {
            if (!server) {
                context = this;
            }
        },
        async resolveId(source, importer, custom) {
            if (importer &&
                source.endsWith('.css') &&
                isSubdir(vuetifyBase, path.isAbsolute(source) ? source : importer)) {
                if (options.styles === 'none') {
                    return '\0__void__';
                }
                else if (options.styles === 'sass') {
                    return source.replace(/\.css$/, '.sass');
                }
                else if (options.styles === 'expose') {
                    awaitResolve();
                    const resolution = await this.resolve(source.replace(/\.css$/, '.sass'), importer, { skipSelf: true, custom });
                    if (resolution) {
                        if (!files.has(resolution.id)) {
                            needsTouch = true;
                            files.add(resolution.id);
                        }
                        return '\0__void__';
                    }
                }
            }
            return null;
        },
        async transform(code, id) {
            if (options.styles === 'expose' &&
                ['.scss', '.sass'].some(v => id.endsWith(v)) &&
                styleImportRegexp.test(code)) {
                debug(`awaiting ${id}`);
                await awaitResolve(id);
                debug(`returning ${id}`);
                return code.replace(styleImportRegexp, '@use ".cache/vuetify/styles.scss"');
            }
        },
        load(id) {
            if (id === '__void__' || id === '\0__void__') {
                return '';
            }
            return null;
        },
    };
}
exports.stylesPlugin = stylesPlugin;
//# sourceMappingURL=stylesPlugin.js.map